<!DOCTYPE html>
<head>
<meta charset="utf-8">
  <meta name="author" content="Alexey Radul" />
  <title>Animated Flow Analysis</title>
  <link href="/css/erudite.css" media="screen" rel="stylesheet" type="text/css" />
<style>
  html { background-color: black; }
  body { background-color: white; }
  /* A section is a slide. It's size is 800x600, and this will never change */
  address, blockquote, dl, fieldset, form, h1, h2, h3, h4, h5, h6, hr, ol, p, pre, table, ul, dl { padding: 0px 20px 0px 20px; }
  h1, h2, h3 {
    text-align: center;
    margin: 10pt 10pt 20pt 10pt;
  }
  ul, ol {
    margin: 10px 10px 10px 50px;
  }
  section.titleslide h1 { margin-top: 200px; }
  h1.title { margin-top: 150px; }
  h1 { font-size: 180%; }
  h2 { font-size: 120%; }
  h3 { font-size: 100%; }
  blockquote { font-style: italic }
  q {
    display: inline-block;
    width: 700px;
    height: 600px;
    background-color: black;
    color: white;
    font-size: 60px;
    padding: 50px;
  }
  footer {
    position: absolute;
    bottom: 10px;
    right: 20px;
  }

  /* Transition effect */
  /* Feel free to change the transition effect for original
     animations. See here:
     https://developer.mozilla.org/en/CSS/CSS_transitions
     How to use CSS3 Transitions: */
  section {
      -moz-transition: left 00ms linear 0s;
      -webkit-transition: left 00ms linear 0s;
      -ms-transition: left 00ms linear 0s;
      transition: left 00ms linear 0s;
  }

  /* Before */
  section { left: -150%; }
  /* Now */
  section[aria-selected] { left: 0; }
  /* After */
  section[aria-selected] ~ section { left: +150%; }

  /* Incremental elements */

  /* By default, visible */
  .incremental > * { opacity: 1; }

  /* The current item */
  .incremental > *[aria-selected] { color: red; opacity: 1; }

  /* The items to-be-selected */
  .incremental > *[aria-selected] ~ * { opacity: 0.2; }
</style>
</head>
<body>
<div class="entry-content">
<section class="slide level6" id="section">
<!--DISPLAY:0-->
<p>I start the example in the middle of analyzing the
Mandelbrot program, so as to focus on the two interesting phenomena of
recursion and higher-order functions.</p>
<p>What you see here is part of
the intermediate state of the analysis, just when it starts on the
call to <code>iterate</code> in the body of <code>mandelbrot?</code>.  We have encountered
just one relevant program point, namely evaluating that expression in
that environment.  The program point is orange because it is ready for us to do a
step of work; the rest of the line is green because we just updated the
analysis data structure with it.  The value recorded in the analysis
is \(\bot\), representing the empty set, because this expression is
not yet known to return anything.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:1-->
<p>In order to get anywhere with our original expression, we first
need to evaluate the symbol <code>iterate</code> in the appropriate
environment, so we add that expression to the analysis structure.  It
is also not known to return anything yet.  Note that the original
expression is now stuck&mdash;the analysis will not make progress on it until
it knows something about <code>iterate</code>.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:2-->
<p>Of course, <code>iterate</code> is bound in our environment to the
closure representing the <code>iterate</code> procedure.  On
discovering this, we update the value of that program point; since
something returning to it changed, the original expression may now be
fruitful to interpret further.  Note: I enclose procedure objects in
brackets to distinguish them from expressions.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:3-->
<p>The next subexpression of the <code>(iterate ...)</code> expression also needs to be
evaluated.</p>
<p>Here is one place where it matters that the language we
are analyzing is strict&mdash;otherwise, we may wish to model making
thunks and analyzing the body of <code>iterate</code> to see whether
they are ever invoked.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:4-->
<p>For <code>(real 400)</code> we first need <code>real</code>...</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:5-->
<p>... which is a (primitive) procedure.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:6-->
<p><code>400</code> evaluates to itself, so now we get to apply
the <code>real</code> primitive to it.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:7-->
<p>At runtime, the <code>real</code> procedure is the identity
function, so in fact applying <code>real</code> to 400 will always
produce 400.  If, however, the flow analysis were that precise, the
effect would be to unroll the loop inside <code>iterate</code> 400
times (you will later see why that would happen).</p>

<p>We do not want
this, and that's why the <code>real</code> primitive appears in the
language&mdash;its purpose is to allow the programmer to introduce
imprecision intentionally.  The effect is achieved by the
analysis-time implementation of the <code>real</code> primitive being
purposely forgetful; to wit, always claiming to return an arbitrary number,
even when its input is actually statically known.  That's what that
\(\R\) is doing there: it is an abstract value signifying that this
program point should be treated as producing arbitrary (scalar) numbers.
</section>

<section class="slide level6" id="section">
<!--DISPLAY:8-->
<p>The expression <code>(real 400)</code> always returns the same
thing as the application of <code>real</code> to 400, which we already
deduced was \(\R\), so we are now ready to continue with the original
<code>(iterate ...)</code> expression.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:16-->
<p>The <code>(step c)</code> subexpression is evaluated much the same
way.  I skip that in the interest of brevity; I also skip how the
application of the compound procedure <code>step</code> to the
argument \(\RR\) produces the <code>closure1</code>
object.  We will soon see a more enlightening
use of the same mechanism.  Suffice it to say that <code>closure1</code>
is an abstract procedure, namely a (concrete) code body together
with an abstract environment, covering possible variation in the values
bound to that code body's free variables.</p>

<p>N.B.: I will be in the habit of eliding no-longer-interesting
analysis entries (such as the variable <code>real</code> duly
evaluating to the appropriate procedure).  They are
there in the abstract evaluator, but we do not need to look at them
all the time.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:19-->
<p>The analysis of the variable <code>c:0</code> is also
straightforward, so now we are ready to analyze the call to the
<code>iterate</code> procedure on (the abstract values representing)
its arguments.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:20-->
<p>Analyzing a call to a compound procedure is like evaluating it:
analyze the evaluation of the procedure's body (here, the
large <code>(if ...)</code> expression) in the (abstract) environment
captured by that procedure's definition.  In DVL, procedures with
different bodies (even if they may have the same "type") always
register as different abstract values.  This choice gives the
flow analysis its specializing power, and also exacts the
cost on compilation time.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:21-->
<p>To analyze an <code>if</code>, first analyze the condition.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:23-->
<p>The <code>count</code> argument was an arbitrary real number (not 400!)</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:26-->
<p>An arbitrary real number may be greater or smaller than zero, so
the comparison must be assumed to return an arbitrary boolean.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:27-->
<p>If the value of the condition had been statically known, we
could proceed down the appropriate branch of the <code>if</code>, as a
normal evaluator would.  Given that it is not, we will need to analyze
both branches.  This is the major difference between abstract
evaluation and concrete evaluation: The flow of control is not fully
known, so alternatives need to be considered.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:28-->
<p>Evaluating the "then" branch of our <code>if</code> is pretty easy.
Given that we learned something about what the branches of
the <code>if</code> do, the <code>(if ...)</code> expression itself is
actionable now.  The exact order of what will happen next is not
deterministic, but let's assume that the second branch gets explored
before the abstract evaluator returns to the <code>(if ...)</code>.
</section>

<section class="slide level6" id="section">
<!--DISPLAY:38-->
<p>Said second branch of the <code>if</code> is another complicated
expression, whose subexpressions get analyzed one at a time.  Neither
the play-by-play here nor the analysis of how the body
of <code>closure1</code> applies to \(\RR\) to produce \( \RR \)
is of any great interest; but note that <code>(- count 1)</code>
is treated as returning \(\R\), not 399.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:39-->
<p>What is of interest is that the recursive <code>(iterate
...)</code>  call has the shape
\(\obj{iterate}, \R, \obj{closure1}, \RR\),
which we
have seen before.  So instead of creating a new analysis entry,
we just record a new dependency between two existing entries.  This is the
complementary way that an abstract interpreter differs from a concrete
one: it remembers the history and doesn't repeat work it has already
done.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:40-->
<p>Now the abstract evaluator has no choice but to update its idea of
what the <code>(if ...)</code> expression returns.  Because
the <code>(if ...)</code> is known to go both ways, and one branch is
known to return \(\RR\), the whole <code>(if ...)</code> is known to
return an abstract value at least as broad as \(\RR\), even though the
other branch is not yet known to return at all.  So we update the
abstract value for <code>(if ...)</code> to \(\RR\).</p>
</section>

<section class="slide level6" id="section">
<p></p>
<p>There is a subtle point to the handling of conditionals and recursion we just saw.
It is important here that the abstract analysis
starts precise (program points are assumed never to return until
proven otherwise, even though this is clearly false)
and incrementally becomes more sound (abstract
values are broadened as evidence is discovered of concrete values that
they must include).  If we had started sound (that is, assuming that a
program point can return anything until proven otherwise), we would
not be able to narrow the return value of the <code>(if ...)</code>
here: <code>(if ...)</code> would appear to be able to return anything
because its <code>(iterate ...)</code> branch appears to be able to
return anything, which appears to be able to return anything because
the <code>(if ...)</code> it reduces to appears to be able to return
anything.  We would have found the least precise rather than the most
precise solution of the equations that enforce soundness.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:41-->
<p>Continuing, the value we deduced for <code>(if ...)</code> propagates, allowing
us to update the calls to <code>iterate</code> in either order.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:42-->
<p>Let's do the interesting one first.  The recursive call
to <code>iterate</code> was a branch of the <code>(if ...)</code>,
which thus becomes actionable again because we discovered something its
value may depend upon.</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:43-->
<p>However, an <code>(if ...)</code> either of whose branches returns
\(\RR\) itself still returns \(\RR\), so re-examining it does not lead
to new insight.  Importantly, that means the <code>(if ...)</code>
expression's dependencies do not become actionable...</p>
</section>

<section class="slide level6" id="section">
<!--DISPLAY:44-->
<p>... and it is possible for the abstract evaluation to finish (with this
segment of code).</p>
</section>
</div>

<!-- SVG output, to avoid zero-height spans -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX","output/SVG"],
    extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js","bbox.js"],
      Macros: {
        R: "{\\mathbb{R}}",
        B: "{\\mathbb{B}}",
        RR: "(\\R\\ . \\R)",
        eps: "\\varepsilon",
        exp: ["{\\textrm{#1}}",1],
        env: ["{\\textrm{env#1}}",1],
        obj: ["{\\left<\\textrm{#1}\\right>}",1],
      },
      equationNumbers: { autoNumber: "AMS" },
      noErrors: { disabled: true },
    },
    SVG: { font: "TeX", mtextFontInherit: true },  // keeps text font consistent
    displayAlign: "left",
    displayIndent: "2.7"
  });
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_SVG"></script>

<style>
/* Modified by axch to suit the local purpose */
body {
  height: 550px !important;
  width: 540px !important;
  margin-top: -275px !important;
  margin-left: -270px !important;
}
</style>

<style>
/* Neutralize MathJax’s computed left shift for display math */
.MathJax_Display .MathJax,
.MathJax_SVG_Display svg {
  margin-left: 3em !important;
  margin-right: 0 !important; /* just in case */
}
/* Safety: ensure display math isn’t re-centered by parent */
.MathJax_Display,
.MathJax_SVG_Display {
  text-align: left !important;
}
/* Hide lingering previews if cleanup is skipped */
.MathJax_Preview { display: none !important; }
</style>

<!-- {{{{ dzslides core
#
#
#     __  __  __       .  __   ___  __
#    |  \  / /__` |    | |  \ |__  /__`
#    |__/ /_ .__/ |___ | |__/ |___ .__/ core :€
#
#
# The following block of code is not supposed to be edited.
# But if you want to change the behavior of these slides,
# feel free to hack it!
#
-->

<!-- Default Style -->
<style>
  * { margin: 0; padding: 0; }
  details { display: none; }
  body {
    width: 800px; height: 600px;
    margin-left: -400px; margin-top: -300px;
    position: absolute; top: 50%; left: 50%;
    overflow: hidden;
  }
  section {
    position: absolute;
    pointer-events: none;
    width: 100%; height: 100%;
  }
  section[aria-selected] { pointer-events: auto; }
  html { overflow: hidden; }
  body { display: none; }
  body.loaded { display: block; }
  .incremental {visibility: hidden; }
  .incremental[active] {visibility: visible; }
</style>

<script>
  var Dz = {
    remoteWindows: [],
    idx: -1,
    step: 0,
    slides: null,
    params: {
      autoplay: "1"
    }
  };

  Dz.init = function() {
    document.body.className = "loaded";
    this.slides = $$("body > div > section");
    this.setupParams();
    this.onhashchange();
    this.setupTouchEvents();
    this.onresize();
  }

  Dz.setupParams = function() {
    var p = window.location.search.substr(1).split('&');
    p.forEach(function(e, i, a) {
      var keyVal = e.split('=');
      Dz.params[keyVal[0]] = decodeURIComponent(keyVal[1]);
    });
  }

  Dz.onkeydown = function(aEvent) {
    // Don't intercept keyboard shortcuts
    if (aEvent.altKey
      || aEvent.ctrlKey
      || aEvent.metaKey
      || aEvent.shiftKey) {
      return;
    }
    if ( aEvent.keyCode == 37 // left arrow
      || aEvent.keyCode == 38 // up arrow
      || aEvent.keyCode == 33 // page up
    ) {
      aEvent.preventDefault();
      this.back();
    }
    if ( aEvent.keyCode == 39 // right arrow
      || aEvent.keyCode == 40 // down arrow
      || aEvent.keyCode == 34 // page down
    ) {
      aEvent.preventDefault();
      this.forward();
    }
    if (aEvent.keyCode == 35) { // end
      aEvent.preventDefault();
      this.goEnd();
    }
    if (aEvent.keyCode == 36) { // home
      aEvent.preventDefault();
      this.goStart();
    }
    if (aEvent.keyCode == 32) { // space
      aEvent.preventDefault();
      this.toggleContent();
    }
  }

  /* Touch Events */

  Dz.setupTouchEvents = function() {
    var orgX, newX;
    var tracking = false;

    var db = document.body;
    db.addEventListener("touchstart", start.bind(this), false);
    db.addEventListener("touchmove", move.bind(this), false);

    function start(aEvent) {
      aEvent.preventDefault();
      tracking = true;
      orgX = aEvent.changedTouches[0].pageX;
    }

    function move(aEvent) {
      if (!tracking) return;
      newX = aEvent.changedTouches[0].pageX;
      if (orgX - newX > 100) {
        tracking = false;
        this.forward();
      } else {
        if (orgX - newX < -100) {
          tracking = false;
          this.back();
        }
      }
    }
  }

  /* Adapt the size of the slides to the window */

  Dz.onresize = function() {
    var db = document.body;
    var sx = db.clientWidth / window.innerWidth;
    var sy = db.clientHeight / window.innerHeight;
    var transform = "scale(" + (1/Math.max(sx, sy)) + ")";

    db.style.MozTransform = transform;
    db.style.WebkitTransform = transform;
    db.style.OTransform = transform;
    db.style.msTransform = transform;
    db.style.transform = transform;
  }


  Dz.getDetails = function(aIdx) {
    var s = $("section:nth-of-type(" + aIdx + ")");
    var d = s.$("details");
    return d ? d.innerHTML : "";
  }

  Dz.onmessage = function(aEvent) {
    var argv = aEvent.data.split(" "), argc = argv.length;
    argv.forEach(function(e, i, a) { a[i] = decodeURIComponent(e) });
    var win = aEvent.source;
    if (argv[0] === "REGISTER" && argc === 1) {
      this.remoteWindows.push(win);
      this.postMsg(win, "REGISTERED", document.title, this.slides.length);
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
      return;
    }
    if (argv[0] === "BACK" && argc === 1)
      this.back();
    if (argv[0] === "FORWARD" && argc === 1)
      this.forward();
    if (argv[0] === "START" && argc === 1)
      this.goStart();
    if (argv[0] === "END" && argc === 1)
      this.goEnd();
    if (argv[0] === "TOGGLE_CONTENT" && argc === 1)
      this.toggleContent();
    if (argv[0] === "SET_CURSOR" && argc === 2)
      window.location.hash = "#" + argv[1];
    if (argv[0] === "GET_CURSOR" && argc === 1)
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
    if (argv[0] === "GET_NOTES" && argc === 1)
      this.postMsg(win, "NOTES", this.getDetails(this.idx));
  }

  Dz.toggleContent = function() {
    // If a Video is present in this new slide, play it.
    // If a Video is present in the previous slide, stop it.
    var s = $("section[aria-selected]");
    if (s) {
      var video = s.$("video");
      if (video) {
        if (video.ended || video.paused) {
          video.play();
        } else {
          video.pause();
        }
      }
    }
  }

  Dz.setCursor = function(aIdx, aStep) {
    // If the user change the slide number in the URL bar, jump
    // to this slide.
    aStep = (aStep != 0 && typeof aStep !== "undefined") ? "." + aStep : ".0";
    window.location.hash = "#" + aIdx + aStep;
  }

  Dz.onhashchange = function() {
    var cursor = window.location.hash.split("#"),
        newidx = 1,
        newstep = 0;
    if (cursor.length == 2) {
      newidx = ~~cursor[1].split(".")[0];
      newstep = ~~cursor[1].split(".")[1];
      if (newstep > Dz.slides[newidx - 1].$$('.incremental > *').length) {
        newstep = 0;
        newidx++;
      }
    }
    if (newidx != this.idx) {
      this.setSlide(newidx);
    }
    if (newstep != this.step) {
      this.setIncremental(newstep);
    }
    for (var i = 0; i < this.remoteWindows.length; i++) {
      this.postMsg(this.remoteWindows[i], "CURSOR", this.idx + "." + this.step);
    }
  }

  Dz.back = function() {
    if (this.idx == 1 && this.step == 0) {
      return;
    }
    if (this.step == 0) {
      this.setCursor(this.idx - 1,
                     this.slides[this.idx - 2].$$('.incremental > *').length);
    } else {
      this.setCursor(this.idx, this.step - 1);
    }
  }

  Dz.forward = function() {
    if (this.idx >= this.slides.length &&
        this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
        return;
    }
    if (this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
      this.setCursor(this.idx + 1, 0);
    } else {
      this.setCursor(this.idx, this.step + 1);
    }
  }

  Dz.goStart = function() {
    this.setCursor(1, 0);
  }

  Dz.goEnd = function() {
    var lastIdx = this.slides.length;
    var lastStep = this.slides[lastIdx - 1].$$('.incremental > *').length;
    this.setCursor(lastIdx, lastStep);
  }

  Dz.setSlide = function(aIdx) {
    this.idx = aIdx;
    var old = $("section[aria-selected]");
    var next = $("section:nth-of-type("+ this.idx +")");
    if (old) {
      old.removeAttribute("aria-selected");
      var video = old.$("video");
      if (video) {
        video.pause();
      }
    }
    if (next) {
      next.setAttribute("aria-selected", "true");
      var video = next.$("video");
      if (video && !!+this.params.autoplay) {
        video.play();
      }
    } else {
      // That should not happen
      this.idx = -1;
      // console.warn("Slide doesn't exist.");
    }
  }

  Dz.setIncremental = function(aStep) {
    this.step = aStep;
    var old = this.slides[this.idx - 1].$('.incremental > *[aria-selected]');
    if (old) {
      old.removeAttribute('aria-selected');
    }
    var incrementals = this.slides[this.idx - 1].$$('.incremental');
    if (this.step <= 0) {
      incrementals.forEach(function(aNode) {
        aNode.removeAttribute('active');
      });
      return;
    }
    var next = this.slides[this.idx - 1].$$('.incremental > *')[this.step - 1];
    if (next) {
      next.setAttribute('aria-selected', true);
      next.parentNode.setAttribute('active', true);
      var found = false;
      incrementals.forEach(function(aNode) {
        if (aNode != next.parentNode)
          if (found)
            aNode.removeAttribute('active');
          else
            aNode.setAttribute('active', true);
        else
          found = true;
      });
    } else {
      setCursor(this.idx, 0);
    }
    return next;
  }

  Dz.postMsg = function(aWin, aMsg) { // [arg0, [arg1...]]
    aMsg = [aMsg];
    for (var i = 2; i < arguments.length; i++)
      aMsg.push(encodeURIComponent(arguments[i]));
    aWin.postMessage(aMsg.join(" "), "*");
  }

  window.onload = Dz.init.bind(Dz);
  window.onkeydown = Dz.onkeydown.bind(Dz);
  window.onresize = Dz.onresize.bind(Dz);
  window.onhashchange = Dz.onhashchange.bind(Dz);
  window.onmessage = Dz.onmessage.bind(Dz);
</script>


<script> // Helpers
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {

      // closest thing possible to the ECMAScript 5 internal IsCallable
      // function
      if (typeof this !== "function")
      throw new TypeError(
        "Function.prototype.bind - what is trying to be fBound is not callable"
      );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
            return fToBind.apply( this instanceof fNOP ? this : oThis || window,
                   aArgs.concat(Array.prototype.slice.call(arguments)));
          };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
  }

  var $ = (HTMLElement.prototype.$ = function(aQuery) {
    return this.querySelector(aQuery);
  }).bind(document);

  var $$ = (HTMLElement.prototype.$$ = function(aQuery) {
    return this.querySelectorAll(aQuery);
  }).bind(document);

  NodeList.prototype.forEach = function(fun) {
    if (typeof fun !== "function") throw new TypeError();
    for (var i = 0; i < this.length; i++) {
      fun.call(this, this[i]);
    }
  }

</script>
<!-- vim: set fdm=marker: }}} -->
</body>
</html>
